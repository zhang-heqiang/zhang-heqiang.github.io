{"meta":{"title":"蓦然回首 博客","subtitle":"小生不才成长史","description":"","author":"蓦然回首","url":"https://zhang-heqiang/github.io.","root":"/"},"pages":[{"title":"作者:慕然回首","date":"2020-01-01T08:26:37.290Z","updated":"2020-01-01T08:26:37.290Z","comments":true,"path":"MRHSDHLS/about.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/about.html","excerpt":"","text":"Welcome to my blog!"},{"title":"留言板","date":"2019-11-24T14:34:57.554Z","updated":"2019-11-24T14:34:57.554Z","comments":true,"path":"MRHSDHLS/comment.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/comment.html","excerpt":"","text":""},{"title":"书香门第","date":"2020-03-09T01:49:56.252Z","updated":"2020-03-09T01:49:56.252Z","comments":true,"path":"MRHSDHLS/books.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/books.html","excerpt":"","text":"欢迎推荐 质量书籍Java初级阅读目前暂无推荐! Java 进阶目前暂无推荐! Java 高级目前暂无推荐!"},{"title":"赞赏","date":"2019-11-24T14:34:46.368Z","updated":"2019-11-24T14:34:46.368Z","comments":true,"path":"MRHSDHLS/donate.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/donate.html","excerpt":"","text":""},{"title":"四海之内皆兄弟","date":"2019-10-08T02:46:25.000Z","updated":"2019-10-08T02:46:25.000Z","comments":true,"path":"MRHSDHLS/links.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/links.html","excerpt":"","text":""},{"title":"Music","date":"2020-03-09T01:07:37.186Z","updated":"2020-03-09T01:07:37.186Z","comments":true,"path":"MRHSDHLS/music.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/music.html","excerpt":"","text":""},{"title":"流连忘返","date":"2020-02-12T14:42:21.200Z","updated":"2020-02-12T14:42:21.200Z","comments":true,"path":"MRHSDHLS/photos.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/photos.html","excerpt":"","text":"欢迎大家供图和分享情侣头像专区"},{"title":"搞笑来源于生活","date":"2020-02-12T14:42:21.182Z","updated":"2020-02-12T14:42:21.182Z","comments":true,"path":"MRHSDHLS/pleasure.html","permalink":"https://zhang-heqiang/github.io./MRHSDHLS/pleasure.html","excerpt":"","text":"有趣的灵魂万里挑一……个人经典语录没有人能让你放弃梦想,你自己试试也许就可以了! 你轻轻的拉着我衣角,微微一笑,还说你没撒娇! 眼看着好朋友都脱单了,而我比较厉害,我脱发! 鱼和熊掌不可兼得,但是单身和穷可以啊! 钱并不能使我快乐,但是花不完的钱可以啊! 这个世界没有谁离不开谁,就算是鱼离开了水,也能烤着吃! 这么冷的天连个一起吃火锅的都没有,还好我自己有钱! 都说熬夜对身体不好,所以我改成了通宵! 长得太帅又亲不到自己是最大的悲哀! 以前比较丑不好意思自拍,现在脸皮厚了! 有钱不一定快乐,但是总比那些没钱的快乐多了啊! 对于不熟的人,你可以打赏来跟我套近乎! 有时间就去健身吧,总不能既单身又胖若两人吧! 听说手机放在枕头旁有辐射,吓得我赶紧把枕头扔了! 第1章、 亚瑟·阿伦博士的36个问题,让你爱上一个人! 1、如果可以跟世上任何人共进晚餐，你会选择谁？ 2、你会想出名吗？以什么样方式出名呢？ 3、在打一通电话之前，你会先排演要在电话中说什么吗？为什么？ 4、你心中最完美的一天是做哪些事呢？ 5、你上一次唱歌给自己听是什么时候？上一次唱给别人听又是何时？ 6、如果你可以活到90岁，并能在30岁过后让体态或大脑一直保持30岁的状态到死，你会选保持体态还是大脑呢？ 7、你有曾经预感过自己会怎么死亡吗？ 8、举出3个你与你对面这位的共同点。 9、你人生中你最感激什么？ 10、如果你能改变你是怎么被抚育成人的，你会想改变什么？ 11、用四分钟跟你对面这位分享你的一生，越详细越好。 12、如果你明早一觉醒来发现自己获得了某种能力，你希望是什么能力？ 13、如果一颗魔法水晶球能告诉你有关你自己，你的人生，你的未来，或任何事情，你会想知道什么？ 14、你有已经梦想了很久，想做的事情吗？你为什么还没去做？ 15、你人生中最大的成就是什么？ 16、一段友情中你最珍视的是什么？ 17、你最珍贵的一段回忆是什么？ 18、你最糟糕的一段回忆是什么？ 19、如果你知道你会在一年后突然死去，你会想改变任何你现在的生活方式吗？为什么？ 20、友情对你来说代表什么？ 21、爱与喜欢在你的人生中有着什么样的地位？ 22、轮流分享你觉得你的恋人应该具有的五项好品质？ 23、你的家庭亲密温暖吗？你觉得你的童年有比别人幸福点吗？ 24、你觉得你跟你的母亲的关系怎么样呢？ 25、用“我们“做主语造三个肯定句，比如“我们都在这个房间里”。 26、完成以下句子“我希望我有一个人能与ta分享…” 27、如果你会跟你对面的人变成亲密好友，分享一下你觉得对方必需得知道的事情。 28、告诉你对面的人你喜欢ta什么：老实回答，说一些你通常不会告诉刚认识的人的答案。 29、与你对面的人分享人生中很尴尬的一刻。 30、你上一次在别人面前哭是什么时候？上一次自己哭是什么时候？ 31、告诉你对面的人你已经喜欢上ta的什么？ 32、有什么人事物是太严重，不能随便开玩笑的？ 33、如果你将在今晚死去，没有任何再与他人交流的机会，你最后悔没有把什么事情跟别人说？ 34、你的家着火了，里面有你所拥有的一切事物、在救出你爱的人，你的宠物后，你还有时间最后再冲回去一趟拯救最后一样任何东西，你会救出什么？为什么？ 35、你家庭中的所有人里，谁的死会让你最难受？为什么？ 36、分享一个你私人的问题，并想你对面的人询问ta会怎么处理、之后再请ta回答，对于你选这个问题，ta有什么看法？ 最后互相凝视4分钟。 通过简单的问题你会对对方有更多的了解,如果对方的回答让你满意,你可能会从心里怼他(她)产生好感,一套问题的交流,四目相对的注视,也许真的会让两个陌生人产生爱情的火花!"}],"posts":[{"title":"jquery 基础语法","slug":"Jquery","date":"2020-03-09T01:41:10.982Z","updated":"2020-03-09T01:41:10.982Z","comments":true,"path":"2020/03/09/Jquery/","link":"","permalink":"https://zhang-heqiang/github.io./2020/03/09/Jquery/","excerpt":"","text":"选择器基本选择器1. $(&quot;div&quot;) 2. $(&quot;#id&quot;) 3. $(&quot;.class&quot;) 4. $(&quot;选择器1,选择器2....&quot;) 层级选择器1. $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 熟性选择器1. $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器 3. $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器 过滤选择器:first 获得选择的元素中的第一个元素 :last 获得选择的元素中的最后一个元素 :not(selector) 不包括指定内容的元素 :even 偶数，从 0 开始计数 :odd 奇数，从 0 开始计数 :eq(index) 指定索引元素 :gt(index) 大于指定索引元素 :lt(index) 小于指定索引元素 :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器:enabled 获得可用元素 :checked 获得单选/复选框选中的元素 :selected 获得下拉框选中的元素 方法内容操作1. html(): 获取/设置元素的标签体内容 2. text(): 获取/设置元素的标签体纯文本内容 3. val()： 获取/设置元素的value属性值 属性操作1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 插件机制1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery 异步请求方式一: $.ajax({键值对});$.ajax({ url:&quot;ajaxServlet1111&quot; , type:&quot;POST&quot; , data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(&quot;出错啦...&quot;) },//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 }); 方式二: $.get()：发送get请求$.get(url, [data], [callback], [type]) 方式三: $.post(): 发送post请求$.post(url, [data], [callback], [type]) $.post(&quot;url&quot;,{username:&quot;name&quot;},function (data) { alert(data); },&quot;text&quot;); 更多详情","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zhang-heqiang/github.io./tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"微信小程序","slug":"wxApp","date":"2020-03-09T01:41:10.917Z","updated":"2020-03-09T01:41:10.917Z","comments":true,"path":"2020/03/09/wxApp/","link":"","permalink":"https://zhang-heqiang/github.io./2020/03/09/wxApp/","excerpt":"","text":"基础语法传参当前页面方法 goClientDetail(e) { var clientId = e.currentTarget.dataset.id; wx.navigateTo({ url: &#39;/pages/partner-info/partner-info?clientId=&#39; + clientId, }); }, //前往的页面 onLoad: function (options) { this.data.page.clientId = options.clientId; this.load(); }, 循环wx:for=&quot;{{tabBar}}&quot; wx:key=&quot;index&quot; {{item.field}} 获取数据bindinput=&quot;getValueMethord&quot; 改变状态条&lt;view wx:for=&quot;{{tabBar}}&quot; wx:key=&quot;index&quot; bindtap=&quot;chooseTab&quot; data-index=&quot;{{index}}&quot; data-status=&quot;{{item.status}}&quot; &gt;{{item.name}}&lt;/view&gt;&lt;/view&gt; chooseTab: function (e) { this.data.page.status = e.currentTarget.dataset.status; this.setData({ page: this.data.page, list: [], }); this.load(); }, 加载 load() { var _this = this; if (_this.data.page.loading) { return; } _this.data.page.loading = true; _this.setData({ page: _this.data.page, isLoading: true }); Api.getClientDetail({ clientId: this.data.page.clientId, status: this.data.page.status, }).then(res =&gt; { _this.data.page.loading = false; _this.setData({ page: _this.data.page }); if (!res.success) { return app.wxToast({ title: res.info }); } console.log(res.data); _this.data.page.hasNext = _this.data.list.length + res.data.length &lt; _this.data.page.total; _this.setData({ page: _this.data.page }); if (!res.data || res.data.length &lt;= 0) { return; } //为集合赋值 for (var i = 0; i &lt; res.data.length; i++) { _this.data.list.push(res.data[i]); } _this.setData({ list: _this.data.list }); }).catch(() =&gt; { _this.data.page.loading = false; _this.setData({ page: _this.data.page }); app.wxToast({ title: &quot;网络异常&quot; }); }).finally(() =&gt; { _this.setData({ isLoading: false }) }); },","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zhang-heqiang/github.io./tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"MySql的用户管理","slug":"MySql的用户管理","date":"2020-02-14T10:25:02.083Z","updated":"2020-02-14T10:25:02.083Z","comments":true,"path":"2020/02/14/MySql的用户管理/","link":"","permalink":"https://zhang-heqiang/github.io./2020/02/14/MySql%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/","excerpt":"","text":"添加用户语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 删除用户语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;; UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;root&#39;; 查询用户：USE myql; SELECT * FROM USER; ROOT用户密码忘记重置1. cmd -- &gt; **net stop mysql** 停止mysql服务(需要管理员运行cmd) 2. 使用无验证方式启动mysql服务： **mysqld --skip-grant-tables** 3. 打开新的cmd窗口,直接输入 **mysql** 命令，敲回车,即可登录成功 4. **use mysql**; 5. **update user set password = password(&#39;新密码&#39;) where user = &#39;root&#39;;** 6. 关闭两个cmd窗口 7. 手动打开任务管理器，结束mysqld.exe 进程 8. 启动mysql服务 **net start mysql ** 9. 使用新密码登录。 权限管理查询权限SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; SHOW GRANTS FOR &#39;root&#39;@&#39;%&#39;; 授予权限GRANT 权限列表 ON 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;; GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;给张三用户授予所有权限，在任意数据库任意表上 撤销权限REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;; REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;","categories":[{"name":"配置","slug":"配置","permalink":"https://zhang-heqiang/github.io./categories/%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"Java内存分析及垃圾回收机制","slug":"Java(Garbage Collection)","date":"2020-01-19T12:46:39.914Z","updated":"2020-01-19T12:46:39.914Z","comments":true,"path":"2020/01/19/Java(Garbage Collection)/","link":"","permalink":"https://zhang-heqiang/github.io./2020/01/19/Java(Garbage%20Collection)/","excerpt":"","text":"栈的特点1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) 2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变 量等) 3. 栈属于线程私有，不能实现线程间的共享 4. 栈的存储特性是“先进后出，后进先出” 5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间 堆的特点1. 堆用于存储创建好的对象和数组(数组也是对象)! 2. JVM只有一个堆，被所有线程共享! 3. 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点1. JVM只有一个方法区，被所有线程共享! 2. 方法区实际也是堆，只是用于存储类、常量相关的信息! 3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 内存管理1.Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。 2.对象空间的分配：使用new关键字创建对象即可 3.对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情：1. 发现无用的对象 2. 回收无用对象占用的内存空间 垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。 垃圾回收相关算法.1.引用计数法 堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。. public class Student { String name; Student friend; public static void main(String[] args) { Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; } } s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。 2.引用可达法(根搜索算法) 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 开发中容易造成内存泄漏的操作1.创建大量无用对象String str = &quot;&quot;; for (int i = 0; i &lt; 10000; i++) { str += i; //相当于产生了10000个String对象 } 2.静态集合类的使用像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。 3.各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。 4.监听器的使用释放对象时，没有删除相应的监听器。 注意:1. 程序员无权调用垃圾回收器。 2. 程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。 3. finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-01-19T12:46:39.907Z","updated":"2020-01-19T12:46:39.907Z","comments":true,"path":"2020/01/19/正则表达式/","link":"","permalink":"https://zhang-heqiang/github.io./2020/01/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"语法特殊字符+ : 代表前面的字符出现（1次或多次) * : 代表前面的字符出现（0次或多次) ? : 代表前面的字符出现（0次或1次) . : 除换行符 \\n 之外的任何单字符 ^ : 匹配输入字符串的开始位置,当该符号在方括号表达式中使用时,要匹配 ^ 字符本身，请使用 \\^ $ : 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39;。要匹配 $ 字符本身，请使用 \\$ 限定符** {n}** : n 是一个非负整数,匹配确定的 n 次 **{n,}** : n 是一个非负整数。至少匹配n 次 **{n,m}**: m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次 定位符**^** : 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 **$** : 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 **\\b** : 匹配一个单词边界，即字与空格间的位置。 **\\B** : 非单词边界匹配。 元字符** x|y** : 匹配 x 或 y。例如，&#39;z|food&#39; 能匹配 &quot;z&quot; 或 &quot;food&quot;。&#39;(z|f)ood&#39; 则匹配 &quot;zood&quot; 或 &quot;food&quot;。 **[xyz]** : 字符集合。匹配所包含的任意一个字符。例如， &#39;[abc]&#39; 可以匹配 &quot;plain&quot; 中的 &#39;a&#39;。 **[^xyz]**: 负值字符集合。匹配未包含的任意字符。例如， &#39;[^abc]&#39; 可以匹配 &quot;plain&quot; 中的&#39;p&#39;、&#39;l&#39;、&#39;i&#39;、&#39;n&#39;。 **[a-z]** : 字符范围。匹配指定范围内的任意字符。例如，&#39;[a-z]&#39; 可以匹配 &#39;a&#39; 到 &#39;z&#39; 范围内的任意小写字母字符。 **[^a-z]**: 负值字符范围。匹配任何不在指定范围内的任意字符。例如，&#39;[^a-z]&#39; 可以匹配任何不在 &#39;a&#39; 到 &#39;z&#39; 范围内的任意字符。 \\d : 匹配一个数字字符。等价于 [0-9]。 \\D : 匹配一个非数字字符。等价于 [^0-9]。 \\w : 匹配字母、数字、下划线。等价于&#39;[A-Za-z0-9_]&#39;。 \\W : 匹配非字母、数字、下划线。等价于 &#39;[^A-Za-z0-9_]&#39;。 格式var reg = //, str = &#39;&#39;; console.log(reg.test(str)); 实例演练更多详情","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"定时器","slug":"定时器","date":"2020-01-19T12:46:39.840Z","updated":"2020-01-19T12:46:39.840Z","comments":true,"path":"2020/01/19/定时器/","link":"","permalink":"https://zhang-heqiang/github.io./2020/01/19/%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"@Scheduled(cron = “ “) cron表达式详解1.cron表达式格式{秒数} {分钟} {小时} {日期} {月份} {星期}{年份(可为空)} 2.cron表达式各占位符解释 {秒数}{分钟} ==&gt; 允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 “*” 代表每隔1秒钟触发； “,” 代表在指定的秒数触发，比如”0,15,45”代表0秒、15秒和45秒时触发任务 “-“代表在指定的范围内触发，比如”25-45”代表从25秒开始触发到45秒结束触发，每隔1秒触发1次 “/”代表触发步进(step)，”/”前面的值代表初始值(““等同”0”)，后面的值代表偏移量，比如”0/20”或者”/20”代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；”5/20”代表5秒触发1次，25秒触发1次，45秒触发1次；”10-45/20”代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次 {小时} ==&gt; 允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常,占位符和秒数一样 {日期} ==&gt; 允许值范围: 1~31,不允许为空值，若值不合法，调度器将抛出SchedulerException异常 {星期} ==&gt; 允许值范围:1~7(SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出SchedulerException异常{年份} ==&gt; 允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出SchedulerException异常 注意：除了{日期}和{星期}可以使用”?”来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数 经典案例“30 * * * * ?” 每半分钟触发任务 “30 10 * * * ?” 每小时的10分30秒触发任务 “30 10 1 * * ?” 每天1点10分30秒触发任务 “30 10 1 20 * ?” 每月20号1点10分30秒触发任务 “30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务 “30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务 “30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务 “30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务 “15,30,45 * * * * ?” 每15秒，30秒，45秒时触发任务 “15-45 * * * * ?” 15到45秒内，每秒都触发任务 “15/5 * * * * ?” 每分钟的每15秒开始触发，每隔5秒触发一次 “15-30/5 * * * * ?” 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 “0 0/3 * * * ?” 每小时的第0分0秒开始，每三分钟触发一次 “0 15 10 ? * MON-FRI” 星期一到星期五的10点15分0秒触发任务 “0 15 10 L * ?” 每个月最后一天的10点15分0秒触发任务 “0 15 10 LW * ?” 每个月最后一个工作日的10点15分0秒触发任务 “0 15 10 ? * 5L” 每个月最后一个星期四的10点15分0秒触发任务 “0 15 10 ? * 5#3” 每个月第三周的星期四的10点15分0秒触发任务","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"ORACLE数据库中的SQL语法机巧","slug":"Oracle使用技巧","date":"2019-12-11T15:14:15.508Z","updated":"2019-12-11T15:14:15.508Z","comments":true,"path":"2019/12/11/Oracle使用技巧/","link":"","permalink":"https://zhang-heqiang/github.io./2019/12/11/Oracle%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"鱼和熊掌不可兼得,但是单身和穷可以啊!!简介未完待续…","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"数组与集合","slug":"数组与集合","date":"2019-12-08T07:45:26.047Z","updated":"2019-12-08T07:45:26.047Z","comments":true,"path":"2019/12/08/数组与集合/","link":"","permalink":"https://zhang-heqiang/github.io./2019/12/08/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/","excerpt":"","text":"这个世界没有谁离不开谁,就算是鱼离开了水,也能烤着吃!数组基础了解定义:用于存储多个元素且是同一种数据类型的容器叫数组 特点: * 数组是有索引的 * 数组一旦创建,长度不能改变 * 数组可以存储基本数据类型也可存储引用数据类型 数组创建动态初始化:数据类型[] 数组名 = new 数据类型[长度]; 静态初始化: 标准的格式: 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...}; 简化的格式: 数据类型[] 数组名 = {元素1,元素2,...}; 集合单例集合collection是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素.JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现. List集合特点:有索引,可以存储重复元素 元素存取有序 Set集合元素存取无序、没有索引、只能通过迭代器或增强for循环遍历 不能存储重复元素 HashSet集合* 底层数据结构是哈希表 * 没有索引,只能通过迭代器和增强for遍历 * 不能存储重复元素,存取可能无序 LinkedHashSet集合* 哈希表和链表实现的Set接口，具有可预测的迭代次序 * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的 * 由哈希表保证元素唯一，也就是说没有重复的元素 TreeSet集合* 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 * 没有带索引的方法，所以不能使用普通for循环遍历 * 由于是Set集合，所以不包含重复元素的集合 遍历方式集合专用遍历方式,通过集合的iterator()方法得到,格式如下: Iterator&lt;String&gt; it = 集合.iterator(); while (it.hasNext()){ System.out.println(it.next()); } Collections是针对集合操作的工具类public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort​(List&lt;T&gt; list)：将指定列表按升序排序 public static void reverse​(List&lt;?&gt; list)：反转指定列表中元素的顺序 public static void shuffle​(List&lt;?&gt; list)：使用默认的随机源随机排列指定的列表 Map集合双列集合 也称为**夫妻对集合**,由 K 和 V 组成的元素,Key 是不允许重复的,K 和 V 允许存储NULL的 但是 K 仅允许存储一次NULL Map集合常用获取功能* V get(Object key) : 根据键获取值 * Set&lt;K&gt; keySet() : 获取所有键的集合 * Collection&lt;V&gt; values() : 获取所有值的集合 * Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取所有键值对对象的集合 Map集合的遍历方式1.先获取键的集合再遍历 Set&lt;String&gt; set = map.keySet(); for (String key : set) { System.out.println(key + &quot; ，&quot; + map.get(key)); } 2.直接获取所有键值对集合 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entrySet) { String key = entry.getKey(); String value = entry.getValue(); System.out.println(key +&quot;=&quot; + value); }","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"数据类型","slug":"数据类型","date":"2019-12-08T06:52:42.353Z","updated":"2019-12-08T06:52:42.353Z","comments":true,"path":"2019/12/08/数据类型/","link":"","permalink":"https://zhang-heqiang/github.io./2019/12/08/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"这么冷的天连个一起吃火锅的都没有,还好我自己有钱!基本数据类型数值型整数 内存占用 取值范围 byte 1 负的2的7次方 ~ 2的7次方-1(-128~127) short 2 负的2的15次方 ~ 2的15次方-1(-32768~32767) int 4 负的2的31次方 ~ 2的31次方-1 long 8 负的2的63次方 ~ 2的63次方-1 浮点数 float 4 1.401298e-45 ~ 3.402823e+38 double 8 4.9000000e-324 ~ 1.797693e+308 字符 char 2 0-65535 非数值型布尔: 内存占用 取值范围 boolean 1 true，false 引用数据类型.类: class 接口: interface 数组: []","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Spring MVC","slug":"Spring MVC","date":"2019-12-01T13:38:22.759Z","updated":"2019-12-01T13:38:22.759Z","comments":true,"path":"2019/12/01/Spring MVC/","link":"","permalink":"https://zhang-heqiang/github.io./2019/12/01/Spring%20MVC/","excerpt":"","text":"听说熬夜对身体不好,于是我改成了通宵!执行流程①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 注解解析@RequestMapping @RequestMapping 用于建立请求 URL 和处理请求方法之间的对应关系 @RequestParam @RequestParam 当请求参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 @ResponseBody @ResponseBody 告知Spring MVC 直接响应回字符串,而不是进行页面跳转 @视图解析器配置&lt;!--配置内部资源视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; SpringMVC的开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"JDK8 的新玩法","slug":"JDK 8 特性","date":"2019-11-26T13:38:51.279Z","updated":"2019-11-26T13:38:51.279Z","comments":true,"path":"2019/11/26/JDK 8 特性/","link":"","permalink":"https://zhang-heqiang/github.io./2019/11/26/JDK%208%20%E7%89%B9%E6%80%A7/","excerpt":"","text":"你有多久没有在十点之前睡觉了?函数式思想面向对象思想: 强调通过对象做事情函数式思想: 尽量忽略面向对象的复杂语法:”强调做什么,而不是以什么方式去做”,Lambda表达式就是函数式思想的体现 Lambda表达式标准格式格式:(形式参数)-&gt;{代码块}本质:一个匿名函数(匿名方法);把方法的名字省掉(诞生于JDK8),在Java中主要作用是简化匿名内部类的写法 使用前提有一个接口,接口中有且仅有一个抽象方法 省略模式1.参数类型可省略,多个参数要么同时省略要么都不省略2.如果参数有且仅有一个,那么包裹参数的小括号可省略3.如果参数代码块语句只有一条,可以省略大括号和分号,如果有return,return也要省略 注意事项1.Java可以推导的就是可以省略的2.必须要有接口,有且仅有一个抽象方法3.必须有上下文环境，才能推导出Lambda对应的接口 区别对比","categories":[{"name":"进阶","slug":"进阶","permalink":"https://zhang-heqiang/github.io./categories/%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Spring","slug":"Spring","date":"2019-11-24T14:44:26.449Z","updated":"2019-11-24T14:44:26.449Z","comments":true,"path":"2019/11/24/Spring/","link":"","permalink":"https://zhang-heqiang/github.io./2019/11/24/Spring/","excerpt":"","text":"Spring（ Spring 之父 Rod Johnson ）简介 Rod Johnson （ Spring 之父）,2017 年 9 月份发布Spring 的最新版本 Spring5.0 通用版（GA）。 Spring是分层的Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：控制反转）和AOP（Aspect Oriented Programming：面向切面编程）为内核。提供了展现层(SpringMVC)和持久层(Spring JDBCTemplate)以及业务层事务管理等众多的企业级应用技术，还能整 合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架! 特点1.方便解耦，简化开发Spring 提供的 IoC容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2.AOP 编程的支持Spring的 AOP 功能，方便进行面向切面编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松实现。 3.声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。 4.方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 5.方便集成各种优秀框架Spring对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的支持。 6.降低 JavaEE API 的使用难度Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。 7.Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 两大核心功能IOC(控制反转)1.Bean标签范围配置 singleton 默认值，单例的 prototype 多例的 | request WEB项目中，Spring创建一个 Bean 的对象，将对象存入到 request 域中 session WEB项目中，Spring创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB项目中，应用在 Portlet环境，如果没有 Portlet 环境那么globalSession -------------------------------------------------------------------------------------- 2.当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 -------------------------------------------------------------------------------------- 3.当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean Bean的生命周期： 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 -------------------------------------------------------------------------------------- 4.Bean的三种实例化方式 1） 使用无参构造方法实例化 &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; --- 2） 工厂静态方法实例化 public class StaticFactoryBean { public static UserDao createUserDao(){ return new UserDaoImpl(); } } --- &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3） 工厂实例方法实例化 public class DynamicFactoryBean { public UserDao createUserDao(){ return new UserDaoImpl(); } } --- &lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; -------------------------------------------------------------------------------------- 5.Bean的依赖注入的数据类型 1) 普通数据类型 2) 引用数据类型 3) 集合数据类型 -------------------------------------------------------------------------------------- 6.引入其他配置文件 &lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; -------------------------------------------------------------------------------------- 7.ApplicationContext的继承体系(spring相关API) 1）ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 -------------------------------------------------------------------------------------- 8.注解开发 @Configuration 声明该类是核心配置类,容器创建时从该类上加载注解 @ComponentScan 注解扫描 @Bean 实例化对象 @PropertySource 加载配置资源 @Import 引入资源 @Component 实例化bean @Controller web层实例化bean @Service service层实例化bean @Repositoury dao层实例化bean @Autowired 依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要 进行扫描以便识别使用注解配置的类、字段和方法。 AOP(面向切面编程)简介AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 作用在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势减少重复代码，提高开发效率，并且便于维护 底层实现 AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 常用术语- Target（目标对象）：代理的目标对象 - Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 - Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 - Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 - Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 - Aspect（切面）：是切入点和通知（引介）的结合 - Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 开发步骤①导入 AOP 相关坐标(aspectlweaver) ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 切点表达式execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 例如: execution(public void com.aop.Target.method()) execution(void com.aop.Target.*(..)) execution(* com.aop.*.*(..)) execution(* com.aop..*.*(..)) execution(* *..*.*(..))","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"GitHub公私钥配置","slug":"GitHub公私钥配置","date":"2019-11-17T01:54:39.517Z","updated":"2019-11-17T01:54:39.517Z","comments":true,"path":"2019/11/17/GitHub公私钥配置/","link":"","permalink":"https://zhang-heqiang/github.io./2019/11/17/GitHub%E5%85%AC%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE/","excerpt":"","text":"SSH简介 公钥和私钥亦称”非对称加密算法”,是”对称加密(用户名和密码)”的进一步提升,每个用户自己设定一把 特定的仅为本人所知的私有密钥，用来解密签名；同时设定一把公共密钥由本人公开，为一组用户共享， 用于加密和验证签名。 目的 Git使用https协议每次pull, push需要输入密码,然后使用SSH密钥操作更加简便,公钥加密内容只能用 私钥解密,私钥加密只能用公钥解密! 步骤 1.本地安装Git(注意:为避免之前配置过,建议先删除.ssh文件夹) 2.桌面右键,点击 Git Bash Here (.ssh文件夹一般在系统盘-&gt;用户下) 3.ssh-keygen -t rsa -C “githhub账号绑定的邮箱” (闭上眼睛,按三次Enter) 4.cd ~/.ssh (进入.ssh文件夹) 5.cat id_rsa.pub 查看此文件,直接输出秘钥 6.复制秘钥,打开GitHub 点击头像-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key 7.私钥名字符合规范即可粘贴秘钥 (一定要注意秘钥的格式正确,否则会添加失败)","categories":[{"name":"配置","slug":"配置","permalink":"https://zhang-heqiang/github.io./categories/%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"SpringBoot","slug":"SpringBoot","date":"2019-11-17T01:08:13.029Z","updated":"2019-11-17T01:08:13.029Z","comments":true,"path":"2019/11/17/SpringBoot/","link":"","permalink":"https://zhang-heqiang/github.io./2019/11/17/SpringBoot/","excerpt":"","text":"SpringBootspringboot简介springboot特点springboot两大核心功能及与原理分析","categories":[{"name":"进阶","slug":"进阶","permalink":"https://zhang-heqiang/github.io./categories/%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://zhang-heqiang/github.io./tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Markdown基础语法","slug":"Markdown","date":"2019-11-12T11:51:05.552Z","updated":"2019-11-12T11:51:05.552Z","comments":true,"path":"2019/11/12/Markdown/","link":"","permalink":"https://zhang-heqiang/github.io./2019/11/12/Markdown/","excerpt":"","text":"一、标题: ## 这是二级标题 : ### 这是二级标题 二、字体**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用&gt;这是引用的内容 &gt;&gt;这是引用的内容 四、分割线第一种: --- 第二种: **** 五、图片![love _4_.jpeg](https://i.loli.net/2019/11/07/S8NZaIQt9LCz67b.jpg)|![love _1_.jpeg](https://i.loli.net/2019/11/07/vea7ACdlWsFj8Sm.jpg)|![love _6_.jpeg](https://i.loli.net/2019/11/07/igT25tXLB94SvCa.jpg) - | - | - ![love _3_.jpeg](https://i.loli.net/2019/11/07/ogWbqdjAlvzIO6p.jpg)|![love _5_.jpeg](https://i.loli.net/2019/11/07/zqfcpsemKXWJZFd.jpg)|![love _2_.jpeg](https://i.loli.net/2019/11/07/8iT42zegNU1vsPk.jpg) 六、超链接: 百度超链接:[百度](http://baidu.com) 七、列表1.无序列表- 列表内容 + 列表内容 * 列表内容 2.有序列表1.列表内容 2.列表内容 3.列表嵌套 上一级和下一级之间敲三个空格即可 八、表格| 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 更多详情请关注菜鸟教程: Markdown","categories":[{"name":"基础","slug":"基础","permalink":"https://zhang-heqiang/github.io./categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zhang-heqiang/github.io./tags/%E5%89%8D%E7%AB%AF/"}]}]}